

# This file was *autogenerated* from the file poseidon.sage
from sage.all_cmdline import *   # import sage library

_sage_const_4 = Integer(4); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1)

# This file is a modified version of the Poseidon permutation reference implementation at https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/poseidonperm_x5_255_5.sage.

def print_words_to_hex(words, n):
    hex_length = int(ceil(float(n) / _sage_const_4 )) + _sage_const_2  # +2 for "0x"
    print(["{0:#0{1}x}".format(int(entry), hex_length) for entry in words])

def print_concat_words_to_large(words, n):
    hex_length = int(ceil(float(n) / _sage_const_4 ))
    nums = ["{0:0{1}x}".format(int(entry), hex_length) for entry in words]
    final_string = "0x" + ''.join(nums)
    print(final_string)

def perm(input_words, alpha, R_F, R_P, round_constants_field, MDS_matrix_field):
    t = len(input_words)

    R_f = int(R_F / _sage_const_2 )

    round_constants_counter = _sage_const_0 

    state_words = list(input_words)

    # First full rounds
    for r in range(_sage_const_0 , R_f):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(_sage_const_0 , t):
            state_words[i] = state_words[i] + round_constants_field[round_constants_counter]
            round_constants_counter += _sage_const_1 
        for i in range(_sage_const_0 , t):
            state_words[i] = (state_words[i])**alpha
        state_words = list(MDS_matrix_field * vector(state_words))

    # Middle partial rounds
    for r in range(_sage_const_0 , R_P):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(_sage_const_0 , t):
            state_words[i] = state_words[i] + round_constants_field[round_constants_counter]
            round_constants_counter += _sage_const_1 
        state_words[_sage_const_0 ] = (state_words[_sage_const_0 ])**alpha
        state_words = list(MDS_matrix_field * vector(state_words))

    # Last full rounds
    for r in range(_sage_const_0 , R_f):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(_sage_const_0 , t):
            state_words[i] = state_words[i] + round_constants_field[round_constants_counter]
            round_constants_counter += _sage_const_1 
        for i in range(_sage_const_0 , t):
            state_words[i] = (state_words[i])**alpha
        state_words = list(MDS_matrix_field * vector(state_words))
    
    return state_words

def sponge(F, data, t, r, o, alpha, R_F, R_P, round_constants_field, MDS_matrix_field, rate_first=True):
    inner_state = [F(_sage_const_0 )] * t
    c = t - r
    rate_start_index = _sage_const_0  if rate_first else c

    for i in range(int(len(data) / r)):  # We assume input is padded
        for j in range(r):
            inner_state[rate_start_index + j] = inner_state[rate_start_index + j] + data[i * r + j]
        inner_state = perm(inner_state, alpha, R_F, R_P, round_constants_field, MDS_matrix_field)

    output = []
    for i in range(o):
        if i % r == _sage_const_0  and i != _sage_const_0 :
            inner_state = perm(inner_state, alpha, R_F, R_P, round_constants_field, MDS_matrix_field)
        output.append(inner_state[rate_start_index + i % r])

    return output

